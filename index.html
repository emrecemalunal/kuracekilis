<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spiral Borulu Bilye • Boss</title>
<style>
  :root { --bg1:#0b1220; --bg2:#0f172a; --ink:#e2e8f0; --muted:#94a3b8; --accent:#38bdf8; }
  html,body{margin:0;height:100%;background:radial-gradient(1200px 600px at 50% -10%,#1e293b,#0b1220);color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:14px;padding:18px}
  h1{margin:0;font-weight:800;letter-spacing:-.02em;font-size:22px;color:#e2e8f0}
  .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .pill{padding:6px 12px;border-radius:999px;background:#0b1220;border:1px solid #233146;color:#cbd5e1;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  .btn{appearance:none;border:none;background:#0ea5e9;color:#081018;font-weight:800;letter-spacing:.3px;
    padding:8px 14px;border-radius:999px;cursor:pointer;box-shadow:0 6px 20px rgba(14,165,233,.35)}
  .btn:active{transform:translateY(1px)}
  canvas{display:block;border-radius:16px;box-shadow:0 20px 70px rgba(0,0,0,.45);border:1px solid #1f2937}
  .hint{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Spiral Borulu Bilye • Boss</h1>
  <div class="hud">
    <div class="pill">Skor: <b id="score">0</b></div>
    <div class="pill">En İyi: <b id="best">0</b></div>
    <button id="restart" class="btn">Sıfırla</button>
    <div class="pill">Kontroller: ← → / A D</div>
  </div>
  <canvas id="c" width="900" height="620"></canvas>
  <div class="hint">Duvar çarpması: +10 • Delikten geçiş: +30 • Alt sınırdan düşerse raund sıfırlanır (puan korunur).</div>
</div>

<script>
(() => {
  const W = 900, H = 620;
  const ctx = document.getElementById('c').getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const btnRestart = document.getElementById('restart');

  // Saha geometri
  const WALL = 26;                         // duvar kalınlığı (üst/yan)
  const PADDLE_W = 160, PADDLE_H = 14;     // platform ölçüleri
  const PADDLE_Y = H - 90;                 // platform yüksekliği
  const BALL_R = 10;                       // bilye yarıçapı
  const G = 1200;                          // yerçekimi (px/s^2)
  const RESTITUTION = 0.98;                // sekmede hız korunumu
  const FRICTION = 0.998;                  // havada sürtünme

  // Delikler (üstte iki küçük delik)
  const HOLE_R = 16;
  const HOLES = [
    { x: W*0.28, y: WALL/2 },
    { x: W*0.72, y: WALL/2 },
  ];

  // Durum
  let keys = {left:false, right:false};
  let paddle = { x: W/2 - PADDLE_W/2, vx:0, speed: 520 };
  let ball   = { x: 0, y: 0, vx: 0, vy: 0, state: 'on_paddle' }; // 'on_paddle' | 'play' | 'in_pipe' | 'dropping'
  let score = 0, best = Number(localStorage.getItem('boss_best')||0);
  bestEl.textContent = best;

  // Spiral boru yollarını hazırla (delikten yan duvar girişine kadar)
  function makeSpiralPath(hole, side){ // side: 'left'|'right'
    const points = [];
    // spiral merkezi: yan duvar ortası
    const cx = (side==='left') ? (W - (W - WALL)/2) - (W - WALL) : WALL + (W - WALL)/2; // sadece görsel için geniş merkez
    const cy = H/2;
    const turns = 3.5;
    const steps = 220;
    const r0 = 10, r1 = 110;
    // delikten spiral merkezine "bağlantı" (kısa çizgi)
    for(let t=0;t<=0.18;t+=0.02){
      const x = hole.x + (cx - hole.x)*t;
      const y = hole.y + (cy - hole.y)*t;
      points.push({x,y});
    }
    // spiral
    for(let i=0;i<=steps;i++){
      const u = i/steps;
      const th = (u*turns*2*Math.PI) * (side==='left' ? 1 : -1);
      const r = r0 + (r1 - r0)*u;
      const x = cx + Math.cos(th)*r;
      const y = cy + Math.sin(th)*r;
      points.push({x,y});
    }
    // çıkış: yan duvardan sahaya
    const exitX = (side==='left') ? WALL + BALL_R + 2 : W - WALL - BALL_R - 2;
    for(let t=0;t<=1;t+=0.02){
      const x = points[points.length-1].x + (exitX - points[points.length-1].x)*t;
      const y = points[points.length-1].y + (H*0.45 - points[points.length-1].y)*t;
      points.push({x,y});
    }
    return points;
  }
  const SPIRAL_LEFT  = makeSpiralPath(HOLES[0], 'left');
  const SPIRAL_RIGHT = makeSpiralPath(HOLES[1], 'right');

  // Çizimler
  function drawArena(){
    // dış çerçeve
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0,0,W,H);

    // saha arkaplanı
    const grd = ctx.createLinearGradient(0, WALL, 0, H);
    grd.addColorStop(0, '#0b1220');
    grd.addColorStop(1, '#0a0f1c');
    ctx.fillStyle = grd;
    ctx.fillRect(WALL, WALL, W-2*WALL, H - WALL); // alt açık

    // duvarlar
    ctx.fillStyle = '#1f2a44';
    // üst
    ctx.fillRect(0, 0, W, WALL);
    // sol
    ctx.fillRect(0, 0, WALL, H);
    // sağ
    ctx.fillRect(W - WALL, 0, WALL, H);

    // delikler
    for(const h of HOLES){
      ctx.beginPath();
      ctx.arc(h.x, h.y, HOLE_R, 0, Math.PI*2);
      ctx.fillStyle = '#0b1220';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#233146';
      ctx.stroke();
    }

    // spiral boruları (dekoratif)
    function drawSpiral(points){
      ctx.strokeStyle = 'rgba(56,189,248,.35)';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      for(let i=0;i<points.length;i++){
        const p = points[i];
        if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
      // iç çizgi
      ctx.strokeStyle = 'rgba(56,189,248,.7)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<points.length;i++){
        const p = points[i];
        if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }
    drawSpiral(SPIRAL_LEFT);
    drawSpiral(SPIRAL_RIGHT);
  }

  function drawPaddle(){
    ctx.fillStyle = '#38bdf8';
    const x = Math.round(paddle.x);
    const y = PADDLE_Y;
    ctx.fillRect(x, y, PADDLE_W, PADDLE_H);
    // parıltı
    ctx.fillStyle = 'rgba(56,189,248,.25)';
    ctx.fillRect(x, y-3, PADDLE_W, 3);
  }

  function drawBall(){
    const {x,y} = ball;
    // gölge
    ctx.beginPath();
    ctx.arc(x+2, y+4, BALL_R, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fill();

    const g = ctx.createRadialGradient(x-5, y-6, 2, x, y, BALL_R);
    g.addColorStop(0, '#e2f2ff');
    g.addColorStop(1, '#8cc8ff');
    ctx.beginPath();
    ctx.arc(x, y, BALL_R, 0, Math.PI*2);
    ctx.fillStyle = g;
    ctx.strokeStyle = '#97d6ff';
    ctx.lineWidth = 1.5;
    ctx.fill();
    ctx.stroke();
  }

  // Skor yardımcıları
  let wallHitCooldown = 0; // ardışık frame’de birden fazla saymamak için
  function addScore(v){
    score += v;
    scoreEl.textContent = score;
    if(score > best){ best = score; bestEl.textContent = best; localStorage.setItem('boss_best', best); }
  }

  // Başlangıç/Reset
  function resetRound(){
    // bilyeyi platform üstüne al
    ball.state = 'on_paddle';
    ball.vx = 0; ball.vy = 0;
    ball.x = paddle.x + PADDLE_W/2;
    ball.y = PADDLE_Y - BALL_R - 1;
  }
  function hardReset(){
    score = 0; scoreEl.textContent = score;
    paddle.x = W/2 - PADDLE_W/2; paddle.vx = 0;
    resetRound();
  }
  hardReset();

  // Kontroller
  document.addEventListener('keydown', e => {
    if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left = true;
    if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right = true;
    if((e.key===' ' || e.key==='Enter') && ball.state==='on_paddle'){
      // başlat: platformun ufak hızına göre ilk açı
      const offset = ((ball.x - (paddle.x + PADDLE_W/2))/ (PADDLE_W/2)); // -1..1
      const speed0 = 520;
      ball.vx = speed0 * 0.6 * offset;
      ball.vy = -speed0 * 0.9;
      ball.state = 'play';
    }
  });
  document.addEventListener('keyup', e => {
    if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left = false;
    if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right = false;
  });
  btnRestart.addEventListener('click', () => hardReset());

  // Pipe durumu
  let pipe = { active:false, t:0, speed: 340, path: null, onExit: null };

  function step(dt){
    // Platform hareketi
    const dir = (keys.left? -1 : 0) + (keys.right? 1 : 0);
    paddle.vx = dir * paddle.speed;
    paddle.x += paddle.vx * dt;
    paddle.x = Math.max(WALL+6, Math.min(W - WALL - 6 - PADDLE_W, paddle.x));

    // On paddle
    if(ball.state==='on_paddle'){
      ball.x = paddle.x + PADDLE_W/2;
      ball.y = PADDLE_Y - BALL_R - 1;
      return;
    }

    // Pipe (spiral içinde ilerleme)
    if(ball.state==='in_pipe'){
      if(!pipe.active || !pipe.path) return;
      pipe.t += pipe.speed * dt;
      const idx = Math.floor(pipe.t);
      const pts = pipe.path;
      if(idx < pts.length){
        const p = pts[idx];
        ball.x = p.x; ball.y = p.y;
      } else {
        // çıkış
        pipe.active = false;
        ball.state = 'play';
        // çıkış yönü: sahaya doğru
        const exitLeft = (pipe.path === SPIRAL_LEFT);
        const s = 520;
        ball.vx = exitLeft ? s*0.85 : -s*0.85;
        ball.vy = -s*0.15;
        if(pipe.onExit) pipe.onExit();
      }
      return;
    }

    // Fizik (oyunda)
    // yerçekimi + sürtünme
    ball.vy += G * dt;
    ball.vx *= FRICTION; ball.vy *= FRICTION;

    // konum güncelle
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // Yan duvarlar
    if(ball.x - BALL_R <= WALL){
      ball.x = WALL + BALL_R;
      ball.vx = Math.abs(ball.vx) * RESTITUTION;
      if(wallHitCooldown<=0){ addScore(10); wallHitCooldown = 0.05; }
    }
    if(ball.x + BALL_R >= W - WALL){
      ball.x = W - WALL - BALL_R;
      ball.vx = -Math.abs(ball.vx) * RESTITUTION;
      if(wallHitCooldown<=0){ addScore(10); wallHitCooldown = 0.05; }
    }

    // Üst duvar (delikler hariç)
    const topY = WALL;
    const hittingTop = (ball.y - BALL_R <= topY);
    if(hittingTop){
      // deliklerde misin?
      let inHole = false, which = -1;
      for(let i=0;i<HOLES.length;i++){
        const h = HOLES[i];
        const dx = ball.x - h.x;
        const dy = (ball.y - BALL_R) - h.y; // top çizgisi
        const d2 = dx*dx + dy*dy;
        if(Math.sqrt(dx*dx + (ball.y - h.y)*(ball.y - h.y)) <= HOLE_R){
          inHole = true; which = i; break;
        }
      }
      if(inHole && ball.vy < 0){
        // +30 puan ve pipe'a gir
        addScore(30);
        ball.state = 'in_pipe';
        pipe.active = true; pipe.t = 0;
        pipe.path = (which===0)? SPIRAL_LEFT : SPIRAL_RIGHT;
        pipe.onExit = null;
        return;
      } else {
        // üst çarpma
        ball.y = topY + BALL_R;
        ball.vy = Math.abs(ball.vy) * RESTITUTION;
        if(wallHitCooldown<=0){ addScore(10); wallHitCooldown = 0.05; }
      }
    }

    // Platform çarpışması (üstten temas)
    const px = paddle.x, py = PADDLE_Y, pw = PADDLE_W, ph = PADDLE_H;
    if(ball.vy > 0 &&
       ball.x > px - BALL_R && ball.x < px + pw + BALL_R &&
       ball.y + BALL_R >= py && ball.y + BALL_R <= py + ph + 12){
      // temas
      ball.y = py - BALL_R - 0.5;
      // çarpışma fiziği: normal yansımaya ek olarak yatay açı, çubuğun hızı ve temas noktasına göre
      const hitOffset = ((ball.x - (px + pw/2)) / (pw/2)); // -1..1
      const baseSpeed = Math.hypot(ball.vx, ball.vy);
      const up = Math.max(520, baseSpeed*0.95);
      ball.vy = -up * (0.75 + 0.25 * (1 - Math.abs(hitOffset))); // merkezde daha dik
      ball.vx = up * 0.75 * (hitOffset) + paddle.vx*0.25;        // kenarda daha yatay + çubuk katkısı
    }

    // Alt sınır (düşerse raund reset)
    if(ball.y - BALL_R > H + 40){
      resetRound();
    }

    // cooldown
    if(wallHitCooldown>0) wallHitCooldown -= dt;
  }

  function draw(){
    drawArena();
    // “Delik” etiketi
    ctx.fillStyle = '#8ab2ff';
    ctx.font = 'bold 12px ui-sans-serif,system-ui';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    for(const h of HOLES){
      ctx.fillText('DELİK', h.x, WALL + 14);
    }

    drawPaddle();
    drawBall();

    // Durum etiketi
    ctx.fillStyle = 'rgba(148,163,184,.9)';
    ctx.font = '600 13px ui-sans-serif,system-ui';
    ctx.textAlign='left';
    let s = '';
    if(ball.state==='on_paddle') s = 'Boşluk/Enter: Başlat';
    else if(ball.state==='in_pipe') s = 'Spiral boruda…';
    ctx.fillText(s, WALL + 10, H - 24);
  }

  // Döngü
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.032, (now - last)/1000);
    last = now;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
